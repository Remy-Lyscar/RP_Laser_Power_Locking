#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jun 27 10:39:06 2024

@author: ipiq
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jun 24 15:30:33 2024

@author: ipiq
"""

import time 
from pyrpl.async_utils import sleep
import numpy as np
import matplotlib.pyplot as plt 
from pyrpl import Pyrpl
import pandas as pd 
import pickle 
import os 
# import path
import allantools 
# import tqdm 
import scienceplots
import numpy.fft as fft 
from scipy.signal import welch 
from scipy.signal import periodogram


# plt.style.use('science')


# Opening of a Pyrpl session to interact with RedPitaya
HOSTNAME = "192.168.1.208"
p = Pyrpl('test3', hostname = HOSTNAME)


# # Access the RedPitaya object in charge of communicating with the board
r = p.rp

s = r.scope

# Reset of all the modules that can be set to 'out1'

# PID Module
pid = r.pid0
pid1 = r.pid1
pid2 = r.pid2
pid.output_direct = 'off'
pid1.output_direct = 'off'
pid2.output_direct = 'off'

# ASG module
asg0 = r.asg0
asg1 = r.asg1
asg0.output_direct = 'off'
asg1.output_direct = 'off'



sleep(5)  

times, signal  = [], []


t0 = time.time()
fs = 50000 # Hz
duration = 5 # seconds

while time.time() - t0 < duration: 
    sleep(1/fs)
    times.append(time.time()-t0)
    signal.append(s.voltage_in1)



# NB: Spectrum analyzer widget uses data from the scope, so both widgets cannot 
# be used simultaneously 

# SpectrumAnalyzer (just like Lockbox and Network Analyzer) are software modules
# so they are available directly at the root of the pyrpl object
# It's also a good habit to deal with hardware modules (st PID or scope)
# using the module managers, ie using "with structure" in the code



# In the next steps I would like to make some plots to discuss the link 
# between PSD (frequency domain) and Allan Variance (time domain)


##### Spectrum Analyzer (and link with Allan Variance) #####

# allows to detect and measure the fast fluctuations and the type of noise 

# following : https://www.geeksforgeeks.org/spectrum-analysis-in-python/

# Why negative frequencies when computing only the fft ? 

# We are interested in the PSD way more than just the fft, ie the plot of the amplitudes 
# as a function of frequency. Indeed, PSD allows to distinguish noise from signal and to detect 
# the type of noise  

# 2 ways:
# scipy.signal.periodogram

# scipy.signal.welch
# Welch Method estimates PSD by averaging periodograms of overlapping signal segments.
# The Welch Method divides the signal into segments, applies a window function, and computes the FFT for each segment.
# It's more reliable when the signal is non-stationary 




### Power-locked signal ###


t = np.array(times)


# FFT  
dft = fft.fft(signal)
freq_fft = fft.fftfreq(t.shape[-1], d=1/fs)
dft = np.abs(dft)

plt.plot(freq_fft, dft) 
plt.xlabel('frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('FFT of the photodiode signal')
plt.show()



# PSD : periodogram 
freq_per, power = periodogram(signal, fs)

plt.semilogy(freq_per, power)
plt.title('Periodogram of the photodiode voltage')
plt.xlabel('Frequency (Hz)')
plt.ylabel('PSD')
plt.show()


# PSD : Welch Method
nperseg = 1024
freq_welch, psd_welch = welch(signal, fs)
# nperseg = length of each segment for which the periodogram is computed
# Shorter segments can lead to a smoother PSD estimate but may also decrease frequency resolution


# I have to give all the parameters, fs, duration, ... with the data and the plots 
plt.semilogy(freq_welch, psd_welch)
plt.title('PSD using Welch Method ')
plt.xlabel('Frequency (Hz)')
plt.ylabel('PSD (VÂ²/Hz)')
plt.tight_layout()
plt.show()


df_data = pd.DataFrame({
                    'times': times, 
                    'signal': signal} )

df_fft = pd.DataFrame({
                    'freq_fft': freq_fft,
                    'fft': dft})

df_per = pd.DataFrame({
                    'freq_per': freq_per, 
                    'power': power} )

df_welch = pd.DataFrame({
                    'freq_welch': freq_welch, 
                    'psd_welch': psd_welch} )


df_acq_settings = pd.DataFrame({
                    'fs': [fs], 
                    'duration': [duration]} )

current_dir = os.path.dirname(os.path.abspath(__file__))

pickle.dump(df_data, open(os.path.join(current_dir, 'spectrum_analysis_free_laser_data_jeu_27_juin(2).pkl'), 'wb'))
pickle.dump(df_fft, open(os.path.join(current_dir, 'spectrum_analysis_free_laser_fft_jeu_27_juin(2).pkl'), 'wb'))
pickle.dump(df_per, open(os.path.join(current_dir, 'spectrum_analysis_free_laser_per_jeu_27_juin(2).pkl'), 'wb'))
pickle.dump(df_welch, open(os.path.join(current_dir, 'spectrum_analysis_free_laser_welch_jeu_27_juin(2).pkl'), 'wb'))
pickle.dump(df_acq_settings, open(os.path.join(current_dir, 'spectrum_analysis_free_laser_acqsettings_jeu_27_juin(2).pkl'), 'wb'))








